-- MariaDB dump 10.19  Distrib 10.5.10-MariaDB, for Linux (x86_64)
--
-- Host: 172.29.4.30    Database: sqlexam
-- ------------------------------------------------------
-- Server version	5.7.33-0ubuntu0.18.04.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `sub_questions`
--

DROP TABLE IF EXISTS `sub_questions`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sub_questions` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `main_id` int(11) NOT NULL,
  `desc` varchar(160) DEFAULT NULL,
  `answer` text NOT NULL,
  `created_at` datetime NOT NULL,
  `updated_at` datetime NOT NULL,
  `difficulty` int(11) NOT NULL,
  `ordered` tinyint(1) NOT NULL DEFAULT '1',
  PRIMARY KEY (`id`),
  KEY `sub_questions_main_id_key` (`main_id`),
  CONSTRAINT `sub_questions_main_id_key` FOREIGN KEY (`main_id`) REFERENCES `main_questions` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=106 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sub_questions`
--

LOCK TABLES `sub_questions` WRITE;
/*!40000 ALTER TABLE `sub_questions` DISABLE KEYS */;
INSERT INTO `sub_questions` VALUES (4,125,'查询Tom和Jerry的存款','select `name`,`amount` from blank_data where name=\'Tom\' or name=\'Jerry\';','2020-11-16 07:17:06','2020-12-28 17:33:56',1,0),(5,125,'查询Tom和Jerry的地址','select `name`,`address` from address_data where name=\'Tom\' or name=\'Jerry\';','2020-11-16 07:18:08','2020-12-30 10:40:34',1,0),(10,1,'编写一个sql语句，查询累计工作时间超过1000的职工，结果返回职工工号eno。','select w.eno \nfrom works w\ngroup by w.eno\nhaving sum(hours) > 1000;','2020-11-25 12:49:46','2021-04-10 20:10:41',1,0),(11,1,'编写一个sql语句，查询没有登记家属的职工，结果返回职工工号eno。','select e.eno\nfrom employees e\nwhere not exists (\n	select *\n	from relations r\n	where r.eno = e.eno\n);','2020-11-25 12:50:18','2021-04-10 20:10:36',1,0),(12,1,'编写一个sql语句，查询所有职工都参与的项目，结果返回项目编号pno。','select p.pno\nfrom projects p\nwhere not exists (\n    select * \n    from employees e\n    where not exists(\n        select *\n        from works w\n        where w.eno = e.eno and w.pno = p.pno\n    )\n)','2020-11-25 12:51:08','2021-03-30 21:59:30',1,0),(13,1,'编写一个sql语句，查询每一个部门中薪水最高的职工，结果返回部门编号dno，薪水最高的职工工号eno和薪水salary，以dno升序排列。','select e1.dno,e1.eno, e1.salary\nfrom employees e1\nwhere e1.salary in (\n	select MAX(salary)\n	from employees e2\n	where e1.dno = e2.dno\n	group by dno\n)\norder by dno;','2020-11-25 12:53:41','2021-03-30 22:01:33',2,1),(14,2,'编写一个sql语句，找出年龄在35以上的并且在2020-09-01至2020-09-30期间没有预定红色（RED）船只的水手，结果返回水手姓名sname。','select s.sname from sailors s\nwhere s.age > 35 and not exists (\n	select * \n	from reserves r join boats b\n	on r.bid = b.bid \n	where  \n	r.sid = s.sid and \n	b.color = \'RED\' and\n	(r.reserve_date between \'2020-09-01\' and \'2020-09-30\')\n);','2020-11-25 14:42:26','2021-04-07 11:13:59',1,0),(15,3,'编写一个sql语句，查询每件商品都购买过的用户，结果返回用户编号customer_id。','select c.customer_id\nfrom customers c\nwhere not exists (\n    select * \n    from products p\n    where not exists (\n        select * \n        from orders o\n        where o.customer_id = c.customer_id and o.product_id = p.product_id\n    )\n);','2020-11-25 14:59:19','2021-03-30 22:11:51',1,0),(16,3,'编写一个sql语句，找出2020-08-01至2020-08-31期间订单数量最多的客户，数量相同时选择customer_id较小的用户，结果返回用户编号customer_id和购买数量order_num。','select o.customer_id, count(distinct order_id) as order_num\nfrom orders o\nwhere o.order_date BETWEEN \'2020-08-01\' and \'2020-08-31\'\nGROUP BY o.customer_id\norder by order_num DESC, customer_id asc\nlimit 1;','2020-11-25 15:01:38','2021-04-06 23:58:13',2,0),(17,3,'编写一个sql语句，找出每件商品的最新订单(可能有多个)，结果返回商品名称product_name，订单号order_id和订单日期order_date，以product_name升序排列。','SELECT\n	p.product_name AS product_name,\n	o.order_id,\n	o.order_date\nFROM\n	orders o,\n	customers c,\n	products p\nWHERE\n	o.customer_id = c.customer_id\nAND o.product_id = p.product_id\nAND (o.product_id, o.order_date) IN (\n	SELECT\n		product_id,\n		MAX(order_date)\n	FROM\n		orders\n	GROUP BY\n		product_id\n)\nORDER BY product_name;\n','2020-11-25 15:10:49','2021-03-30 22:07:24',2,1),(18,3,'编写一个sql语句，找到每个用户最近三笔订单。若用户订单少于3笔，则返回该用户的全部订单，结果返回用户名customer_name，订单编号order_id和订单日期order_date，以custromer_name升序，order_date降序排列。','SELECT c.name customer_name,o2.order_id,o2.order_date\nFROM orders o1,orders o2,customers c\nWHERE o1.customer_id=o2.customer_id AND c.customer_id=o2.customer_id\nGROUP BY c.name,o2.order_id,o2.customer_id,o2.order_date\nHAVING SUM(o1.order_date>=o2.order_date)<=3\nORDER BY c.name,o2.order_date desc;','2020-11-25 15:14:53','2021-03-30 22:11:35',2,1),(19,4,'编写一个sql语句，查询参加比赛场次最多的选手，若参与比赛场次相同，选择用户编号player_id较小的选手，结果返回用户编号player_id和参与的比赛数量match_num。','select player_id, count(*) as match_num from \n(\n	select p.player_id \n	from players p join matches m\n	on p.player_id = m.first_player or p.player_id = m.second_player\n) tot_player\ngroup by player_id\nORDER BY match_num DESC,player_id asc\nlimit 1;','2020-11-25 15:28:48','2021-03-30 22:13:15',2,0),(20,4,'编写一个sql语句，查询各组进行的比赛场次，结果返回组号group_id及各组的场次数match_num。','select group_id, count(match_id) as match_num\nfrom matches\ngroup by group_id;','2020-11-25 15:31:30','2021-03-30 22:13:39',1,0),(21,4,'编写一个sql语句，查询分差最大的一场比赛，若分差相同，选择编号match_id较小的比赛，结果返回比赛编号match_id和分差sub（大于0）。','select match_id, ABS(first_score - second_score) as sub\nfrom matches\norder by ABS(first_score - second_score) desc, match_id asc\nlimit 1;','2020-11-25 15:37:23','2021-03-30 22:14:39',2,0),(22,4,'编写一个sql语句，查找每组中的获胜者。每组的获胜者是在组内累积得分最高的选手。如果有得分相同的情况，则认为player_id 最小的选手获胜，结果返回组号group_id和选手编号player_id，以group_id升序排列。','select group_id,min(player_id) as player_id\nfrom\n    (select player,sum(score) as score\n    from\n        ((select first_player player,first_score score from matches)\n        union all\n        (select second_player player,second_score score from matches)) t\n    group by player) a\n    right join players p on a.player=p.player_id\nwhere (group_id,score) in\n(select group_id,max(score) as mx\nfrom \n    (select player,sum(score) as score\n    from\n        ((select first_player player,first_score score from matches)\n        union all\n        (select second_player player,second_score score from matches)) t\n    group by player) a\n    right join players p on a.player=p.player_id\ngroup by group_id)\ngroup by group_id\norder by group_id;','2020-11-25 15:39:59','2021-03-30 22:29:39',3,1),(23,5,'编写一个sql查询，查找订单数量最多的一天以及当天的订单数量，订单数相同时选择日期最小的一天，结果返回日期order_date和订单数量num。','select order_date,count(*) as num\nfrom orders \ngroup by order_date\norder by num DESC,order_date asc\nlimit 1;','2020-11-25 15:46:15','2021-03-30 22:30:34',1,0),(24,5,'编写一个sql语句，查找买到过自己最喜欢的商品的用户，结果返回用户编号user_id。','select u.user_id \nfrom users u\nwhere exists (\n	select * \n	from orders o LEFT JOIN items i\n	on o.item_id = i.item_id\n	where o.buyer_id = u.user_id and u.favorite_brand = i.item_brand\n);','2020-11-25 15:47:57','2021-03-30 22:30:59',2,0),(25,5,'编写一个sql语句，查询每个用户的注册日期以及在2019年作为买家的订单总数，结果返回用户编号user_id，注册日期join_date和订单数量orders_in_2019，以user_id升序排列。','select user_id, join_date, count(order_id) orders_in_2019\nfrom users left join orders\non user_id = buyer_id and year(order_date)=\'2019\'\ngroup by user_id\norder by user_id;','2020-11-25 15:50:21','2021-04-07 11:54:25',2,1),(26,5,'编写一个sql语句，查询每一个用户按顺序卖出的第二件商品是否是他们最喜爱的品牌。结果返回卖家编号seller_id和是否是最喜爱品牌的情况if_fav_brand（取值为\'yes\'，\'no\'，售出小于2件时返回 ‘no’），以seller_id升序排列。','select user_id seller_id, if(favorite_brand = item_brand, \'yes\', \'no\') if_fav_brand\nfrom users left join (\n    select seller_id, item_brand\n    from (\n        select o1.seller_id, o1.item_id\n        from orders o1 join orders o2\n        on o1.seller_id = o2.seller_id\n        group by o1.order_id\n        having sum(o1.order_date > o2.order_date) = 1\n    ) o join items i\n    on o.item_id = i.item_id\n) tmp\non user_id = seller_id\norder by seller_id;','2020-11-25 16:15:32','2021-04-14 00:12:51',3,1),(27,6,'编写一个sql语句，求出好友申请的总通过率accept_rate，用2位小数表示。通过率计算公式为接受好友申请的数目除以申请总数（申请和接收可能会有重复，此时均视作一次）。','select round(\n    ifnull(\n    (select count(distinct requester_id ,accepter_id) from accepted_requests) / \n    (select count(distinct sender_id ,send_to_id) from friend_requests)\n    ,0)\n    ,2) as accept_rate ;','2020-11-25 16:29:45','2021-04-10 21:29:14',2,0),(28,6,'编写一个sql语句，查询发出过申请，但所有申请都未通过的用户，结果返回用户编号user_id。','select distinct fr.sender_id user_id\nfrom friend_requests fr \nwhere exists (\n	select * from friend_requests fr2\n	where fr2.sender_id = fr.sender_id\n) and not exists (\n	select * from accepted_requests \n	where fr.sender_id = requester_id\n);','2020-11-25 16:30:33','2021-03-30 22:47:34',2,0),(29,6,'编写一个sql语句，查询每个月的通过率，结果返回月份mon及通过率accept_rate（不包括通过率为0的月份），以mon升序排列。','select t1.m1 as mon, t1.accept/t2.alla accept_rate from\n(select month(accept_date) m1, count(distinct concat(requester_id, accepter_id)) accept\nfrom accepted_requests \ngroup by month(accept_date)) t1\ninner join\n(select month(request_date) m2, count(distinct concat(sender_id, send_to_id)) alla\nfrom friend_requests \ngroup by month(request_date)) t2\non t1.m1=t2.m2\norder by mon;','2020-11-25 16:34:38','2021-03-30 22:48:20',2,1),(30,6,'编写一个sql语句，找出拥有最多的好友的用户以及他拥有的好友数目，好友数相同时选择user_id较小的用户，结果返回用户编号user_id和好友数目friend_num。','select user_id, count(*) friend_num\nfrom \n((select requester_id user_id\nfrom accepted_requests\n)\nunion all\n(select accepter_id user_id\nfrom accepted_requests)) t3\ngroup by user_id\norder by friend_num desc,user_id asc\nlimit 1;','2020-11-25 16:36:42','2021-03-30 22:48:56',2,0),(31,7,'编写一个sql语句，查询所有浏览过自己文章的作者，结果返回用户编号id，以id升序排列。','SELECT distinct author_id as id\nFROM views\nWHERE author_id = viewer_id\nORDER BY author_id;','2020-11-25 16:44:02','2021-03-30 22:52:20',1,1),(32,7,'编写一个sql语句，找出曾在一天内阅读至少两篇文章的人，结果返回用户编号viewer_id，以viewer_id升序排列。','select  distinct viewer_id from views \ngroup by viewer_id,view_date\nhaving count(distinct article_id) >= 2\norder by viewer_id;','2020-11-25 16:45:09','2021-03-30 22:53:20',2,1),(33,7,'编写一个sql语句，找出阅读文章总数最多的用户，阅读数量一样时选择view_id较小的用户，结果返回用户编号viewer_id和阅读文章数量article_num。','select viewer_id , count(*) as article_num  from views \ngroup by viewer_id \norder by article_num desc, viewer_id asc\nlimit 1;','2020-11-25 16:47:33','2021-04-07 00:20:29',2,0),(34,7,'编写一个sql语句，找出2020-08-01至2020-08-31期间阅读过3号作者文章的人，结果返回用户编号id，以id升序排列。','select distinct viewer_id as id\nfrom views v1  \nwhere exists(\n	select *\n	from views v2\n	where v2.viewer_id = v1.viewer_id and v2.author_id = 3\n				and (v2.view_date BETWEEN \'2020-08-01\' and \'2020-08-31\')\n)\norder by id;','2020-11-25 16:48:57','2021-04-07 11:16:15',2,1),(35,8,'编写一个sql语句，查询每个用户最近一天登录的日子，结果返回用户编号user_id和登录日期date，以user_id升序排列。','SELECT user_id, MAX(login_date) as date FROM logins\nGROUP BY user_id\nORDER BY user_id;','2020-11-25 18:08:13','2021-03-30 22:54:43',1,1),(36,8,'编写一个sql语句，查询新登录用户的留存率，即新用户第1天登陆之后，第2天再次登陆的概率，结果返回留存率rate。','select \ncount(distinct user_id)*1.0/(select count(distinct user_id) from logins) as rate\nfrom logins\nwhere (user_id,login_date)\nin (select user_id,DATE_ADD(min(login_date),INTERVAL 1 DAY) from logins group by user_id);','2020-11-25 18:09:23','2021-04-12 11:04:12',3,0),(37,8,'编写一个sql语句，查询登录新用户个数不少于2个的日期，结果返回日期login_date和登录新用户个数new_user_num，以login_date升序排序。','select l.mdate as login_date,count(user_id) as new_user_num\nfrom (\n    select user_id,min(login_date) as mdate\n    from logins\n    group by user_id) as l\ngroup by l.mdate \nhaving new_user_num >= 2\norder by login_date;','2020-11-25 18:11:07','2021-03-30 22:55:57',2,1),(38,8,'编写一个sql语句，查询每个日期新用户次日留存率（包括留存率为0的日期），即该日登录的新用户第二日仍然登录的概率，返回日期date和留存率rate，保留小数点后3位，以date升序排列。','SELECT a.date, ROUND(COUNT(b.user_id) * 1.0/COUNT(a.user_id), 3) AS rate\nFROM (\n    SELECT user_id, MIN(login_date) AS date\n    FROM logins\n    GROUP BY user_id) a\nLEFT JOIN logins b\nON a.user_id = b.user_id\nAND b.login_date = DATE_ADD(a.date,INTERVAL 1 day)\nGROUP BY a.date\nUNION\nSELECT login_date date, 0.000 AS rate\nFROM logins\nWHERE login_date NOT IN (\n    SELECT MIN(login_date)\n    FROM logins\n    GROUP BY user_id)\nORDER BY date;','2020-11-25 18:16:53','2021-03-30 22:56:49',3,1),(39,9,'编写一个sql语句，查询各个岗位分数的平均数，结果返回岗位名称job以及平均成绩avg，保留小数点后3位，以avg降序排序。','select job,round(sum(score)*1.0/count(user_id),3) as avg from grades\ngroup by job order by avg desc;','2020-11-25 18:51:53','2021-03-30 22:57:28',1,1),(40,9,'编写一个sql语句，查询分数大于其所在岗位平均分的用户，结果返回用户编号user_id，岗位名称job和该用户分数score，以user_id升序排序。','select grades.* from grades join \n(select job,round(sum(score)*1.0/count(user_id),3) as avg from grades\ngroup by job) as t\non grades.job=t.job\nwhere grades.score > t.avg\norder by user_id;','2020-11-25 18:52:57','2021-03-30 22:58:35',2,1),(41,9,'编写一个sql语句，查询各个岗位分数升序排列之后的中位数所在的位置start，end（范围从1开始，一个岗位参与人数为单数时 start = end，为偶数时 end = start + 1），以job升序排序。','SELECT job,FLOOR((COUNT(*)+1)/2) AS `start`,FLOOR((COUNT(*)+1)/2)+if(COUNT(*) % 2=1,0,1) AS `end` \nfrom grades\nGROUP BY job \norder by job;','2020-11-25 18:55:23','2021-04-07 00:07:37',1,1),(42,9,'编写一个sql语句，查询分数位于各个岗位中位数范围内的用户信息，结果返回用户编号user_id，岗位名称job，用户分数score和排名t_rank，以user_id升序排列。','select B.* from\n(SELECT job,FLOOR((COUNT(*)+1)/2) AS `start`,FLOOR((COUNT(*)+1)/2)+if(COUNT(*) % 2=1,0,1) AS `end` \nFROM grades  GROUP BY job) A\nJOIN\n(select g1.*, (\n    select count(distinct g2.score) \n    from grades g2 \n    where g2.score>=g1.score and g1.job=g2.job) as t_rank\nfrom grades g1 ) B\non (A.job=B.job  and B.t_rank between A.start and A.end)\norder by B.user_id;','2020-11-25 18:56:14','2021-03-30 23:04:04',3,1),(43,10,'编写一个sql语句，查找Technology部门工资的平均值，结果返回部门名称department和平均工资avg_salary。','select d.department_name as department, AVG(e.salary) as avg_salary\nfrom employees e LEFT JOIN departments d\non e.department_id = d.department_id\nwhere d.department_name = \'Technology\'\ngroup by e.department_id;','2020-11-25 19:11:07','2021-03-30 23:04:25',1,0),(44,10,'编写一个sql语句，查找各部门最高工资与最低工资的差值，结果返回部门名称department和差值sub。','select d.department_name department, MAX(salary)-MIN(salary) as sub\nfrom employees e LEFT JOIN departments d \non e.department_id = d.department_id\ngroup by e.department_id;','2020-11-25 19:12:40','2021-03-30 23:07:16',2,0),(45,10,'编写一个sql语句，获取各个部门第二高的薪水，结果返回部门名称department，员工姓名name和工资salary，以department升序排列。','select d.department_name as department,t.name,t.salary from \ndepartments d join \n(select name,salary,department_id from employees e1 where 1 = \n(select count(distinct(salary)) from employees e2 \nwhere e1.department_id = e2.department_id \nand e1.salary < e2.salary)) t\non d.department_id = t.department_id\norder by department;','2020-11-25 19:17:46','2021-03-30 23:04:59',3,1),(46,10,'编写一个sql语句，找出每个部门获得前三高工资的所有员工，结果返回部门名称department，员工姓名name和工资salary，以department升序，salary降序排列。','select d.department_name as department,e.name ,e.salary as salary\nfrom employees as e left join departments as d \non e.department_id = d.department_id\nwhere e.id in\n(\n    select e1.id\n    from employees as e1 left join employees as e2\n    on e1.department_id = e2.department_id and e1.salary < e2.salary\n    group by e1.id\n    having count(distinct e2.salary) <= 2\n)\nand e.department_id in (select department_id from departments)\norder by d.department_name asc,e.salary desc;','2020-11-25 19:20:08','2021-03-30 23:07:09',3,1),(47,2,'编写一个sql语句，找出预定了所有船的水手，结果返回水手姓名sname。','select s.sname from sailors s\nwhere not exists (\n	select * from boats b \n	where not exists (\n		select * from reserves r\n		where r.sid = s.sid and r.bid = b.bid\n	)\n);','2020-11-25 20:03:45','2021-03-30 22:02:23',1,0),(48,2,'编写一个sql语句，找出2020-05-01至2020-05-31期间预定过绿色船（GREEN）的等级最高的水手，结果返回水手姓名sname。','select s.sname\nfrom sailors s\nwhere exists(\n	select *\n	from reserves r join boats b\n	on r.bid = b.bid\n	where b.color = \'GREEN\' and r.sid = s.sid and r.reserve_date between \'2020-05-01\' and \'2020-05-31\'\n)\norder by rating DESC\nlimit 1;','2020-11-25 20:04:04','2021-04-07 11:18:28',2,0),(49,2,'编写一个sql语句，找出年龄在35岁以上，并且在2020-08-01至2020-08-31期间同时预定了红色船（RED）和绿色船（GREEN）的水手，结果返回水手姓名sname。','select s.sname\nfrom sailors s\nwhere s.age > 35 and exists(\n	select * \n	from reserves r join boats b\n	on r.bid = b.bid\n	where r.sid = s.sid and b.color = \'GREEN\' and r.reserve_date between \'2020-08-01\' and \'2020-08-31\'\n) and exists (\n	select * \n	from reserves r join boats b\n	on r.bid = b.bid\n	where r.sid = s.sid and b.color = \'RED\' and r.reserve_date between \'2020-08-01\' and \'2020-08-31\'\n);','2020-11-25 20:10:28','2021-04-10 20:16:19',2,0),(52,11,'查询那些既没有最多，也没有最少参与者的活动的名字，可以以任何顺序返回结果，activities 表的每项活动的参与者都来自friends 表。结果字段:activity ','select activity\nfrom friends\ngroup by activity\nhaving count(*)>any(\n    select count(*) from friends group by activity\n) and count(*)<any(\n    select count(*) from friends group by activity\n)','2020-11-26 11:28:29','2021-04-13 21:34:13',3,0),(53,11,'查询在2月20~2月28之间能进行的活动及参加该活动的朋友名字。结果字段包含name，activity。','select name, friends.activity\nfrom activities,friends\nwhere activities.activity=friends.activity and (startDate between \'2020-02-20\' and \'2020-02-28\') and (endDate between \'2020-02-20\' and \'2020-02-28\')','2020-11-26 11:29:13','2020-12-30 11:01:55',2,0),(55,11,'查询进行eating的用户有哪些。结果字段：name','select friends.name \nfrom friends,activities\nwhere friends.activity=activities.activity and friends.activity=\'eating\'','2020-11-26 11:30:52','2021-04-13 21:36:47',1,0),(56,12,'查找在 2020 年 2 月 平均评分最高 的电影名称。 如果有相同的，返回字典序较小的电影名称。结果字段：title','select title from \n(select m.title,avg(mr.rating) as rt from movie_rating mr\ninner join movies m\non m.movie_id = mr.movie_id \ninner join users u \non u.user_id = mr.user_id \nwhere mr.created_at between \'2020-02-01\' and \'2020-02-29\'\ngroup by m.movie_id\norder by rt desc,m.title asc\nlimit 1) b','2020-11-26 11:33:33','2021-04-10 21:21:42',3,1),(57,12,'查找评论电影数量最多的用户名。 如果出现平局，返回字典序较小的用户名。结果字段：name','(SELECT name\nFROM users AS U\nINNER JOIN movie_rating AS MR\nON U.user_id = MR.user_id\nGROUP BY U.user_id\nORDER BY COUNT(*) DESC, name\nLIMIT 1)\n','2020-11-26 11:34:06','2021-04-10 12:05:40',3,1),(58,12,'求每部电影的最高分，最低分以及平均分。结果字段包含movie_id, title, avg_rating, max_rating, min_rating。','select movies.movie_id,title, avg(rating)as avg_rating, max(rating) as max_rating, min(rating) as min_rating\nfrom movies, movie_rating\nwhere movies.movie_id=movie_rating.movie_id\ngroup by movies.movie_id','2020-11-26 11:34:36','2021-04-12 10:35:12',2,0),(59,12,'查询一月份评论过电影的用户。结果集包含，name , title, created_at。','select name, title,created_at\nfrom movie_rating,users,movies\nwhere movie_rating.created_at between \'2020-01-01\' and \'2020-01-31\' and movie_rating.movie_id=movies.movie_id and movie_rating.user_id=users.user_id','2020-11-26 11:35:06','2020-12-30 11:03:00',2,0),(60,12,'查找用户id为1的用户看过的电影以及所给的评分。结果字段包含user_id，name，title，rating。','select movie_rating.user_id,name,title,rating\nfrom users,movie_rating,movies\nwhere movies.movie_id=movie_rating.movie_id and movie_rating.user_id=users.user_id and movie_rating.user_id=1','2020-11-26 11:35:30','2021-04-10 20:55:55',1,0),(61,13,'查询金额最大的发票所对应的发票号，用户ID，用户姓名。结果字段：invoice_id，price, user_id，customer_name','select invoice_id,price,invoices.user_id,customer_name\nfrom invoices,customers\nwhere invoices.user_id=customers.customer_id and price=(select max(price) from invoices)','2020-11-26 11:50:08','2021-04-10 21:09:40',2,0),(62,13,'求拥有发票数大于1的用户的联系人名字及电子邮件。结果字段：user_id，contact_name，contact_email','select t.user_id,contact_name,contact_email\nfrom\n(\n    SELECT user_id,count(*) count_temp\n    FROM invoices\n    GROUP BY user_id  \n    HAVING count_temp>1\n)t, customers,contacts \nwhere t.user_id=customers.customer_id and customers.customer_id=contacts.user_id','2020-11-26 11:50:58','2021-04-10 21:09:52',2,0),(63,13,'求拥有一张发票的顾客及其电子邮箱。结果字段包含：user_id，customer_name，email','select t.user_id,customer_name,email\nfrom\n(\n    SELECT user_id,count(*) count_temp\n    FROM invoices\n    GROUP BY user_id  \n    HAVING count_temp=1\n)t, customers\nwhere t.user_id=customers.customer_id','2020-11-26 11:51:26','2021-04-10 21:10:06',2,0),(64,13,'求拥有联系人的顾客的id和姓名以及联系人姓名。结果字段customer_id，customer_name，contact_name','select customer_id,customer_name,contact_name\nfrom customers,contacts\nwhere customer_id=user_id','2020-11-26 11:52:08','2021-04-10 21:23:18',1,0),(65,14,'每组的获胜者是在组内累积得分最高的选手。若平局player_id 最小选手获胜。查询每组中的获胜者。结果字段包含group_id,player_id。','SELECT t.group_id, t.player_id\n\nFROM\n(SELECT p1.group_id, t4.scores, MIN(t4.player_id) AS player_id\nFROM\n(SELECT t3.player_id, SUM(t3.score) AS scores\nFROM\n((SELECT first_player AS player_id, SUM(first_score) AS score\nFROM matches\nGROUP BY first_player)\nUNION ALL\n(SELECT second_player AS player_id, SUM(second_score) AS score\nFROM matches\nGROUP BY second_player)) AS t3\n\nGROUP BY t3.player_id) AS t4\nINNER JOIN players AS p1\nON t4.player_id=p1.player_id\nGROUP BY p1.group_id, t4.scores) AS t\n\nWHERE (t.group_id, t.scores) IN\n(\nSELECT p.group_id, MAX(t2.scores)\nFROM\n(SELECT player_id, SUM(score) AS scores\nFROM\n((SELECT first_player AS player_id, SUM(first_score) AS score\nFROM matches\nGROUP BY first_player)\nUNION ALL\n(SELECT second_player AS player_id, SUM(second_score) AS score\nFROM matches\nGROUP BY second_player)) AS t1\nGROUP BY player_id) AS t2\nINNER JOIN\nplayers AS p\nON t2.player_id=p.player_id\nGROUP BY p.group_id\n)\n','2020-11-26 11:56:17','2020-12-30 23:40:34',3,0),(66,14,'查询姓名为Aron的参赛者参加过的训练赛赛事分数。结果字段包含player_name ,match_id, score（不能为0）。 ','select player_name, match_id, t.score\nfrom\n(\nselect player_name, match_id,second_score as score\nfrom players, matches\nwhere (players.player_id=matches.first_player or players.player_id=matches.second_player) and players.player_name=\'Aron\' \n\nunion\n\nselect player_name, match_id,first_score as score\nfrom players, matches\nwhere (players.player_id=matches.first_player or players.player_id=matches.second_player) and players.player_name=\'Aron\'\n) t\nwhere t.score<>0','2020-11-26 11:57:32','2020-12-30 23:33:13',2,0),(67,14,'根据Scores表查询性别为‘F’在每一天的总分，并按性别和日期对结果排序。结果字段包含gender, day, total。','select s1.gender,s1.day,sum(s2.score_points) as total from scores s1\ninner join scores s2\non s1.gender = s2.gender \nand s1.day >= s2.day \nand s1.gender=\'F\'\ngroup by s1.gender,s1.day  \norder by s1.gender,s1.day','2020-11-26 11:58:53','2020-12-30 23:33:27',2,1),(68,14,'查询在1月进行训练赛的参赛者姓名，性别，分数。结果字段包含player_name ,gender, score_points。','select player_name,gender,score_points\nfrom scores\nwhere day between \'2020-01-01\' and \'2020-01-31\'','2020-11-26 11:59:21','2020-12-30 23:33:32',1,0),(69,14,'查找在scores表中获得最低分数的球员的姓名以及他的id。结果字段包含player_name, player_id，score_points.','select players.player_name, player_id, score_points as score_points\nfrom scores,players\nwhere scores.player_name=players.player_name and score_points=(select min(score_points) from scores)','2020-11-26 11:59:43','2020-12-31 00:16:14',2,0),(70,15,'查询顾客ID为1 的最近三笔订单。如果该用户订单少于 3 笔则返回其全部订单。结果按order_date 降序排列。结果字段：customer_name,customer_id,order_id,order_date','SELECT c.name as customer_name,o2.customer_id,o2.order_id,o2.order_date\nFROM orders o1,orders o2,customers c\nWHERE\n	o1.customer_id = o2.customer_id  and o2.customer_id = 1 and c.customer_id = o2.customer_id\nGROUP BY\n	c.name,\n	o2.order_id,\n	o2.customer_id,\n	o2.order_date\nHAVING\n	SUM(o1.order_date >= o2.order_date) <= 3\nORDER BY\n	c.name,\n	o2.customer_id,\n	o2.customer_id,\n	o2.order_date desc','2020-11-26 14:14:53','2021-04-10 12:03:32',3,1),(71,15,'找到每一个顾客最经常订购的商品。结果表单：每一位至少下过一次单的顾客id和他最经常订购的商品的ID和名字,按customer_id,product_id升序排列。结果字段：customer_id,product_id,p.product_name','select t2.customer_id,t3.product_id,p.product_name\nfrom\n(select t1.customer_id,max(t1.cnt) freq\nfrom\n(select customer_id,product_id,count(order_id) cnt\nfrom orders\ngroup by customer_id,product_id) t1\ngroup by t1.customer_id) t2 join (\nselect customer_id,product_id,count(order_id) cnt\nfrom orders\ngroup by customer_id,product_id\n) t3 on t2.freq=t3.cnt and t2.customer_id=t3.customer_id\njoin products p on p.product_id=t3.product_id\norder by customer_id, product_id\n','2020-11-26 14:16:57','2021-04-08 23:53:08',3,1),(72,15,'找到每件商品的最新订单(可能多个). 结果以商品名字升序排列。若相同则按商品id升序，再同以订单id 升序. 结果字段：product_name, product_id, order_id, order_date','select product_name, o.product_id, order_id, order_date\nfrom orders o left join products p\nusing(product_id)\nwhere (product_id, order_date) in\n(\n    select product_id, max(order_date) order_date\n    from orders\n    group by product_id\n)\norder by product_name, product_id, order_id','2020-11-26 14:20:11','2021-04-08 23:53:30',2,1),(73,15,'查询在 2020 年 8 月份被卖出的产品名字。结果字段： product_name','SELECT product_name\nFROM products JOIN orders USING (product_id)\nWHERE order_date LIKE \"2020-08%\"\nGROUP BY product_name','2020-11-26 14:20:57','2021-04-08 23:53:39',1,0),(74,15,'查询购买了产品ID 为1和产品 ID为2却没有购买产品ID为3的顾客的 ID 和姓名。结果字段： customer_id, name','SELECT\n    customer_id, name\nFROM\n    customers\nWHERE\n    customer_id NOT IN (\n        SELECT customer_id\n        FROM orders\n        WHERE product_id =3\n    ) AND customer_id IN (\n        SELECT customer_id\n        FROM orders\n        WHERE product_id =2\n    ) AND customer_id IN (\n        SELECT customer_id\n        FROM orders\n        WHERE product_id =1\n    )\nORDER BY customer_id','2020-11-26 14:21:30','2021-04-08 23:53:51',2,0),(75,16,'找出与”赵正义”在同一天借书的读者姓名、所在单位及借书日期 。结果字段： name,company','SELECT name,company,\n      (SELECT borrow_date FROM borrows WHERE reader_id =\n      (SELECT reader_id FROM readers WHERE name=\'赵正义\') )   \n                  borrow_date\nFROM readers WHERE reader_id = (\n    SELECT reader_id FROM borrows WHERE  borrow_date = \n        (SELECT borrow_date FROM borrows WHERE reader_id =\n        (SELECT reader_id FROM readers WHERE name=\'赵正义\') ) \n    AND reader_id != (SELECT reader_id FROM readers \n                                   WHERE name=\'赵正义\') );','2020-11-26 14:24:24','2021-04-08 23:54:25',3,0),(76,16,'查询财会系2006年7月以后没有借书的读者借书证号、姓名及单位。结果字段：reader_id,name,company','SELECT reader_id,name,company FROM readers \n    WHERE company=\'财会系\' and reader_id NOT IN\n            (SELECT reader_id FROM borrows \n             WHERE borrow_date>=\'2006-08-01\');','2020-11-26 14:24:45','2021-04-08 23:54:38',1,0),(77,16,'找出当前至少借阅了2本图书(大于等于2本)的读者姓名及其所在单位。结果字段：name,company','SELECT name,company FROM readers WHERE reader_id in\n       (SELECT distinct reader_id FROM borrows \n         GROUP BY reader_id having count(book_id)>=2);','2020-11-26 14:26:19','2021-04-08 23:54:51',2,0),(78,16,'题目：找出作者为李某的书籍的被借阅情况。结果字段：writer, book_name, borrow_date。','SELECT writer,book_name,\n   (SELECT borrow_date FROM borrows WHERE book_id in\n      (SELECT book_id from books WHERE writer LIKE \'李%\')) as borrow_date\nFROM books WHERE writer LIKE \'李%\';','2020-11-26 14:26:37','2021-04-10 12:02:58',2,0),(79,16,'查找“高等教育出版社”的所有图书名称(BOOK_NAME)及单价(PRICE)，结果按单价降序排序。结果字段：book_name,price','SELECT DISTINCT(book_name),price FROM books\n    WHERE output=\'高等教育出版社\' \n    ORDER BY price DESC;','2020-11-26 14:26:56','2021-04-08 23:55:17',1,1),(80,17,'查询2019-01-01到2019-12-31期间任务连续同状态的起止日期。如果任务失败/成功就是失败/成功状态的起止日期。结果按照起始日期排序。结果字段：period_state，start_date，end_date','select period_state,min(date) start_date,max(date) end_date from (\nselect \n\"failed\" period_state,\nfail_date as date,\nif(datediff(@pre_date,@pre_date:=fail_date)=-1,@id,@id:=@id+1) id\nfrom failed,(select @id:=0,@pre_date:=NULL)tmp1\nunion\nselect \n\"succeeded\" period_state,\nsuccess_date as date,\nif(datediff(@pre_date,@pre_date:=success_date)=-1,@id,@id:=@id+1) id\nfrom succeeded,(select @id:=0,@pre_date:=NULL)tmp2\n) tmp\nwhere date BETWEEN \"2019-01-01\" AND \"2019-12-31\"\ngroup by id,period_state\nORDER BY start_date ASC\n','2020-11-26 14:30:44','2021-04-13 21:43:01',3,1),(81,17,'查询所有活跃的业务。结果字段只包含business_id。','SELECT business_id\nFROM events AS e\nJOIN (\n    SELECT event_type, AVG(occurences) AS eventAvg\n    FROM events\n    GROUP BY event_type\n) AS e1 \nON e.event_type = e1.event_type\nWHERE e.occurences > e1.eventAvg\nGROUP BY business_id\nHAVING COUNT(*) >= 2','2020-11-26 14:33:08','2021-03-05 10:37:36',3,0),(82,17,'分别求出每个event事件的成功天数与失败天数。结果字段包含：event_type，success_count，fail_count。','Select x.event_type as event_type , IFNULL(x.success_count, 0) as success_count, IFNULL(y.fail_count, 0) as fail_count \nfrom events e\nleft join \n(select count(success_date) as success_count, event_type from succeeded group by event_type) as x on e. event_type= x. event_type\nLeft join\n(select count(fail_date) as fail_count, event_type from failed group by event_type) as y on y. event_type= e. event_type\ngroup by event_type,success_count,fail_count','2020-11-26 14:34:14','2021-04-13 21:55:20',3,0),(83,17,' 求出reviews事件在18年12月份系统里的最小的失败次数。结果字段：occurences，event_type，fail_count','Select min(occurences) as occurences, e.event_type, IFNULL(t.fail_cnt, 0) as fail_count\nfrom events e \nleft join\n(select count(fail_date) as fail_cnt, event_type from failed \nwhere fail_date between  \'2018-12-01\' and \'2018-12-31\' and event_type=\'reviews\') as t\non t. event_type= e. event_type \nwhere t.event_type=\'reviews\'','2020-11-26 14:37:17','2021-04-13 21:55:33',2,0),(84,17,'求一下事件类型发生次数最多的商业ID。结果字段仅包含business_id。','select business_id\nfrom events\nwhere occurences=(select max(occurences)\n                   from events)\n','2020-11-26 14:37:50','2020-12-30 11:10:23',1,0),(85,18,'查询没有学全所有课程的同学的信息。结果字段包含s_id, s_name, s_sex, s_birthday。','select s.* from \n    students s where s.s_id in(\n        select s_id from scores where s_id not in(\n            select a.s_id from scores a \n                join scores b on a.s_id = b.s_id and b.c_id=2\n                join scores c on a.s_id = c.s_id and c.c_id=3\n            where a.c_id=1))','2020-11-26 14:55:25','2021-04-08 23:57:26',1,0),(89,19,'查询每个部门工资最高的员工，结果字段包含：department_name,employee,salary','SELECT\n	department.NAME AS department_name,\n	employee.NAME AS employee,\n	salary \nFROM\n	employee,\n	department \nWHERE\n	employee.DepartmentId = department.Id \n	AND ( employee.DepartmentId, Salary ) \n    IN (SELECT DepartmentId, max( Salary ) \n        FROM employee \n        GROUP BY DepartmentId )','2020-11-26 15:21:26','2021-04-09 00:03:08',2,0),(90,19,'查询收入超过他们经理的员工的姓名。结果字段:employee','SELECT\n    a.Name AS \'employee\'\nFROM\n    employee AS a,\n    employee AS b\nWHERE\n    a.ManagerId = b.Id\n        AND a.Salary > b.Salary\n;','2020-11-26 15:21:56','2021-04-09 00:03:23',1,0),(91,19,'查询职员表中第二高的薪水（注：若AB薪资都是3000，C薪资2000，则第二高指的是C的2000）。结果字段：SecondHighestSalary','SELECT\n    (SELECT DISTINCT\n            salary\n        FROM\n            employee\n        ORDER BY Salary DESC\n        LIMIT 1 OFFSET 1) AS SecondHighestSalary\n;','2020-11-26 15:22:50','2021-04-09 00:03:51',2,0),(92,20,'查询工资高于部门号为30的所有员工工资水平的员工信息。 结果字段：empno，ename，job，mgr，hiredate，sal，comm，deptno。','select * from emp \nwhere sal > ( select max(sal) from emp where deptno = 30);  ','2020-11-26 15:25:04','2021-04-13 22:01:29',2,0),(93,20,'返回工资处于第四级别的员工的姓名。结果字段包含：ename，sal。','select ename,sal from emp e ,salgrade s \nwhere e.sal >= s.losal and e.sal <= s.hisal \nand s.grade = 4; ','2020-11-26 15:25:24','2021-04-13 22:04:54',1,0),(94,20,'返回工资为二等级的职员名字、部门名称、工资和二等级的最低工资和最高工资 。结果字段： ename，dname，sal，losal，hisal。','select ename ,dname ,sal ,losal,hisal from emp,dept,salgrade \nwhere emp.deptno = dept.deptno and grade = 2 \nand sal >= losal and sal < hisal; ','2020-11-26 15:25:42','2021-04-13 22:12:56',2,0),(95,20,'返回工资等级高于smith且直属领导编号为7298的员工信息。结果字段：empno，ename，job，mgr，hiredate，sal，comm，deptno。','select e.* from emp e, salgrade s \nwhere e.mgr=7698 and s.hisal < e.sal and s.grade = \n  ( select grade from salgrade s ,emp e \nwhere s.losal < e.sal and s.hisal > e.sal and e.ename = \'smith\'); ','2020-11-26 15:25:57','2021-04-13 22:03:03',2,0),(96,20,'计算出部门号为20的员工的年薪，并且对年薪进行升序排序。结果字段包含ename，deptno，ySalary。','select ename, deptno,sal * 12 as ySalary \nfrom emp \nwhere deptno=20\norder by ySalary; ','2020-11-26 15:26:24','2021-04-13 22:05:08',2,1),(98,18,'查询课程号为1和2的成绩在第2名到第3名的学生信息及该课程成绩。结果字段包含：s_id, s_name, s_birthday, s_sex, rank, s_score, c_id','  select d.*,c.排名,c.s_score,c.c_id from (\n                select a.s_id,a.s_score,a.c_id,@i:=@i+1 as 排名 from scores a,(select @i:=0)s where a.c_id=1    \n            )c\n            left join students d on c.s_id=d.s_id\n            where 排名 BETWEEN 2 AND 3\n            UNION\n            select d.*,c.排名,c.s_score,c.c_id from (\n                select a.s_id,a.s_score,a.c_id,@j:=@j+1 as 排名 from scores a,(select @j:=0)s where a.c_id=2   \n            )c\n            left join students d on c.s_id=d.s_id\n            where 排名 BETWEEN 2 AND 3','2020-11-26 19:15:55','2020-12-30 11:11:19',3,0),(99,18,'查询各科成绩最高分，最低分，不及格率，中等率和优秀率。结果字段包含：c_id，c_name，max_score，min_score，\'不及格率\'，\'中等率\'和\'优秀率\'（及格率、中等率和优秀率结果在0到1之间，保留两位小数）。注：不及格<60，中等>=60且<90，优秀>=90。','select a.c_id,b.c_name,MAX(s_score)as max_score,MIN(s_score) as min_score,\n    ROUND(SUM(case when a.s_score<60 then 1 else 0 end)/SUM(case when a.s_score then 1 else 0 end),2) as \'不及格率\',\n    ROUND(SUM(case when a.s_score>=60 and a.s_score<90 then 1 else 0 end)/SUM(case when a.s_score then 1 else 0 end),2) as \'中等率\',\n    ROUND(SUM(case when a.s_score>=90 then 1 else 0 end)/SUM(case when a.s_score then 1 else 0 end),2) as \'优秀率\'\n    from scores a left join courses b on a.c_id = b.c_id GROUP BY a.c_id,b.c_name','2020-11-26 19:18:06','2021-04-14 11:16:16',3,0),(100,18,'统计各科成绩各分数段人数：课程编号,课程名称,[100-85],[85-70],[70-60],[0-60]及所占百分比。结果字段：c_name, c_id，85-100, percent, 70-80, percent, 60-70, percent, 0-60, percent。',' select distinct f.c_name,a.c_id,b.`85-100`,b.percent,c.`70-85`,c.percent,d.`60-70`,d.percent,e.`0-60`,e.percent from scores a\n                left join (select c_id,SUM(case when s_score >85 and s_score <=100 then 1 else 0 end) as `85-100`,\n                                            ROUND(100*(SUM(case when s_score >85 and s_score <=100 then 1 else 0 end)/count(*)),2) as percent\n                                from scores GROUP BY c_id)b on a.c_id=b.c_id\n                left join (select c_id,SUM(case when s_score >70 and s_score <=85 then 1 else 0 end) as `70-85`,\n                                            ROUND(100*(SUM(case when s_score >70 and s_score <=85 then 1 else 0 end)/count(*)),2) as percent\n                                from scores GROUP BY c_id)c on a.c_id=c.c_id\n                left join (select c_id,SUM(case when s_score >60 and s_score <=70 then 1 else 0 end) as `60-70`,\n                                            ROUND(100*(SUM(case when s_score >60 and s_score <=70 then 1 else 0 end)/count(*)),2) as percent\n                                from scores GROUP BY c_id)d on a.c_id=d.c_id\n                left join (select c_id,SUM(case when s_score >=0 and s_score <=60 then 1 else 0 end) as `0-60`,\n                                            ROUND(100*(SUM(case when s_score >=0 and s_score <=60 then 1 else 0 end)/count(*)),2) as percent\n                                from scores GROUP BY c_id)e on a.c_id=e.c_id\n                left join courses f on a.c_id = f.c_id','2020-11-26 19:18:45','2020-12-30 11:11:34',3,0),(101,18,'查询没学过张三老师讲授的任一门课程的学生姓名。结果字段：s_name。','select a.s_name from students a where a.s_id not in (\n    select s_id from scores where c_id = \n                (select c_id from courses where t_id =(\n                    select t_id from teachers where t_name = \'张三\')) \n                group by s_id);\n','2020-11-26 19:22:51','2021-04-08 23:58:39',1,0),(103,13,'为每张发票编写一个SQL查询，结果字段包含：invoice_id，customer_name，price，contacts_cnt（该顾客的联系人数量），trusted_contacts_cnt（可信联系人的数量）。查询的结果按照 invoice_id 排序。','select i.invoice_id, c1.customer_name, i.price, \n    count(ct.contact_name) contacts_cnt ,\n    count(c2.customer_name) trusted_contacts_cnt \nfrom invoices i join customers c1 on i.user_id=c1.customer_id\n    left join contacts ct on i.user_id=ct.user_id\n    left join customers c2 on ct.contact_email=c2.email\ngroup by i.invoice_id\norder by i.invoice_id','2020-12-30 23:16:36','2021-04-12 10:56:02',3,1),(104,19,'编写SQL查询来查找每个部门的薪水中位数。若某一部门薪水情况是：1000,2000,3000,4000，则中位数为2000及3000.结果字段：departmentId, salary','select b.departmentId,b.salary\nfrom (\n    select DepartmentId,salary,\n    case @com when DepartmentId then @rk:=@rk+1 else @rk:=1 end rk,\n    @com:=DepartmentId\n    from employee,(select @rk:=0, @com:=\'\') a\n    order by DepartmentId,salary) b\nleft join \n    (\n    select DepartmentId,count(1)/2 cnt from employee group by DepartmentId) c\non b.DepartmentId=c.DepartmentId\nwhere b.rk in (cnt+0.5,cnt+1,cnt);','2021-01-02 16:06:41','2021-04-09 00:04:39',3,0),(105,11,'编写sql语句查询进行相同活动的用户的数量，要求结果字段有cnt（cnt表示用户的数量，依据题意至少为2），activity。结果字段：cnt，activity','select count(activity) as cnt, activity\nfrom friends\nGROUP BY activity\nhaving cnt > 1\n','2021-01-02 16:51:29','2021-04-13 21:37:40',1,0);
/*!40000 ALTER TABLE `sub_questions` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2021-06-27 21:07:37
